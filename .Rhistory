n_cy
t<-1
# calculate the transition probabilities for the cycle based on health state t
m_p        <- Probs(m_M[, t], v_Ts, t, p_HS, p_HD, p_SD)
m_p
samplev
m_p
# sample next state based on transition probabilities in m_p
m_M[,t+1]  <- samplev(m_p)
m_M[,t+1]
# sample next state based on transition probabilities in m_p
m_M[,t+1]  <- samplev(m_p)
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c_trt[,t+1] <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = T, dc = v_dc[t+1])
m_c
colSums(m_c)
colSums(m_c)/n_ind
file_path <- getwd()
# Load packages
if (!require('pacman')) install.packages('pacman'); library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load( "dplyr", "flexsurv", "ggplot2", "openxlsx", "dampack", "matrixStats")
# load (install if required) packages from GitHub
#install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version
p_load_gh("DARTH-git/darthtools")
# Load Excel workbook
wb_path <- paste0(file_path, "/3_state.xlsm")
wb      <- loadWorkbook(wb_path)
# Load functions
source("fun_3_state.R")
####################
# Input parameters
####################
n_sim  <- as.numeric(read.xlsx(wb, namedRegion = "n_sims",     colNames = F))    # Number of simulations
n_ind  <- as.numeric(read.xlsx(wb, namedRegion = "n_i",        colNames = F))    # Number of individuals
n_t    <- as.numeric(read.xlsx(wb, namedRegion = "n_years",    colNames = F))    # Number of time cycles (in years)
n_s    <- as.numeric(read.xlsx(wb, namedRegion = "n_s",        colNames = F))    # Number of states
init_s <- as.numeric(read.xlsx(wb, namedRegion = "state_init", colNames = F))    # Initial states
c_l    <- as.numeric(read.xlsx(wb, namedRegion = "cy_len",     colNames = F))    # Cycle length
times  <- seq(from = 0, to = n_t, by = c_l)                                      # Vector of time points
n_cy   <- length(times)                                                          # Number of time points
trial_t<- as.numeric(read.xlsx(wb, namedRegion = "n_yr_t",     colNames = F))    # Number of years of trial
surv_t <- as.numeric(read.xlsx(wb, namedRegion = "surv_t",     colNames = F))    # Present survival at time:
p_adv  <- as.numeric(read.xlsx(wb, namedRegion = "p_adverse",  colNames = F))    # Probability of AE
v_s    <- as.character(read.xlsx(wb, namedRegion = "name_states", colNames = F)) # Vector of states
v_grp  <- as.character(read.xlsx(wb, namedRegion = "name_groups", colNames = F)) # Vector of group names
psa    <- as.character(read.xlsx(wb, namedRegion = "psa", colNames = F))         # Probabilistic Analysis? (Y/N)
dwc    <- as.numeric(read.xlsx(wb, namedRegion = "dwc", colNames = F))           # Discounting rate for costs
dwe    <- as.numeric(read.xlsx(wb, namedRegion = "dwe", colNames = F))           # Discounting rate for effects
v_dc   <- 1 / ((1 + dwc) ^ (times))                                              # Vector of discount weights for costs
v_de   <- 1 / ((1 + dwe) ^ (times))                                              # Vector of discount weights for utilities
# Ceiling Ratio (willingness to pay)
ceiling_ratio <- read.xlsx(wb, namedRegion = "ceiling_ratio", colNames = F)
###########################################
# Input parameters: Surv
## psa params generated by psa_param_gen.R
###########################################
# Import sampled survival distribution coefficients from Excel
m_coef_HS <- as.matrix(   read.xlsx(wb, namedRegion = "psa_HS",  colNames = F)) # Healthy to Sick
m_coef_HD <- as.matrix(   read.xlsx(wb, namedRegion = "psa_HD",  colNames = F)) # Healthy to Dead
m_coef_SD <- as.matrix(   read.xlsx(wb, namedRegion = "psa_SD",  colNames = F)) # Sick to Dead
# Selected distribution from Excel
dist_HS   <- as.character(read.xlsx(wb, namedRegion = "dist_HS", colNames = F)) # Healthy to Sick
dist_HD   <- as.character(read.xlsx(wb, namedRegion = "dist_HD", colNames = F)) # Health to Dead
dist_SD   <- as.character(read.xlsx(wb, namedRegion = "dist_SD", colNames = F)) # Sick to Dead
#########################################
# Input parameters: Costs
#########################################
m_costs    <- read.xlsx(wb, namedRegion = "m_cost", colNames = F)
cost_names <- m_costs[1,]
m_costs    <- m_costs[-1,]
m_costs    <- matrix(as.numeric(as.matrix(m_costs)), nrow = n_sim)
colnames(m_costs) <- cost_names
#########################################
# Organize Costs in matrices for SoC and Trt
## Rows   : Simulation
## Columns: State
#########################################
m_costs_soc <- matrix(c(rowSums(m_costs[,c("cost_PF_acq_soc", "cost_PF_admin_soc", "cost_PF_soc")]), # Healthy
rowSums(m_costs[,c("cost_P_acq_soc", "cost_P_soc")]),                        # Sick
rep(0, n_sim)),                                                              # Dead
nrow = n_sim)
m_costs_trt <- matrix(c(rowSums(m_costs[,c("cost_PF_acq_trt", "cost_PF_admin_trt", "cost_PF_trt")]), # Healthy
rowSums(m_costs[,c("cost_P_acq_trt", "cost_P_trt")]),                        # Sick
rep(0, n_sim)),                                                              # Dead
nrow = n_sim)
# Costs for adverse events
costs_adv <- m_costs[,"cost_adv"]
#########################################
# Import Utilities
#########################################
u_H   <- as.numeric(read.xlsx(wb, namedRegion = "util_H", colNames = F))
u_S   <- as.numeric(read.xlsx(wb, namedRegion = "util_S", colNames = F))
u_D   <- as.numeric(read.xlsx(wb, namedRegion = "util_D", colNames = F))
u_trt <- as.numeric(read.xlsx(wb, namedRegion = "util_T", colNames = F))
v_utils     <- c(u_H, u_S, u_D)
v_utils_trt <- c(u_H, u_trt, u_D)
####################
# Initialize vectors
####################
v_M_init  <- rep(v_s[init_s], times = n_ind)    # Vector state individuals start in
v_Ts_init <- ifelse(v_M_init == v_s[2],c_l, 0)  # Vector with the time of being Sick at the start of the model
######################################
# Run microsim and write to txt files
######################################
outputs <- df_trial  <- data.frame(le = as.numeric(),
costs = as.numeric(),
effects = as.numeric(),
`trt costs` = as.numeric(),
`trt effects` = as.numeric())
m_surv <- matrix(NA,
nrow = n_sim,
ncol = n_cy)
k<-1
# m_M is used to store the health state information over time for every individual
# m_c, m_u, m_c_trt, m_u_trt are used to store cost, utilities, treatment costs and treatment utilities for every individual, respectively
m_M  <-  matrix(nrow = n_ind, ncol = n_cy ,
dimnames = list(paste("ind" , 1:n_ind, sep = " "),
paste("year", times, sep = " ")))
m_c <- m_u <- m_c_trt <- m_u_trt <- m_M
m_M[, 1] <- v_M_init                                  # initial health state for individual i
v_Ts     <- v_Ts_init                                 # initialize time since illness onset for individual i
v_adv    <- rbinom(n = n_ind, size = 1, prob = p_adv) # sample individuals who will experience adverse events
v_dead   <- as.numeric(m_M[,1] == "Dead")
# costs and effects
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = T, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1])
m_c_trt[,1] <- Costs(v_M = m_M[,1], adverse = T, v_adverse = v_adv, trt = T, k = k, dc = v_dc[1])
m_c    [v_dead == 1, 1] <- m_c    [v_dead == 1, 1] + m_costs[k,"cost_D"]
m_c_trt[v_dead == 1, 1] <- m_c_trt[v_dead == 1, 1] + m_costs[k,"cost_D"]
m_u[, 1]     <- Utils(v_M = m_M[,1], trt = F, de = v_de[1])
m_u_trt[, 1] <- Utils(v_M = m_M[,1], trt = T, de = v_de[1])
p_HS <- model.dist.f(dist.v = dist_HS, d.data = m_coef_HS[k,], t = times, step = c_l)[-1]
p_HD <- model.dist.f(dist.v = dist_HD, d.data = m_coef_HD[k,], t = times, step = c_l)[-1]
p_SD <- model.dist.f(dist.v = dist_SD, d.data = m_coef_SD[k,], t = times, step = c_l)[-1]
p_HS
p_HD
p_SD
m_c
costs_adv
m_costs_soc
head(m_costs_soc)
m_costs[,"cost_D"]
m_costs_trt
v_dc
m_c
for(k in 1:n_sim){
# m_M is used to store the health state information over time for every individual
# m_c, m_u, m_c_trt, m_u_trt are used to store cost, utilities, treatment costs and treatment utilities for every individual, respectively
m_M  <-  matrix(nrow = n_ind, ncol = n_cy ,
dimnames = list(paste("ind" , 1:n_ind, sep = " "),
paste("year", times, sep = " ")))
m_c <- m_u <- m_c_trt <- m_u_trt <- m_M
m_M[, 1] <- v_M_init                                  # initial health state for individual i
v_Ts     <- v_Ts_init                                 # initialize time since illness onset for individual i
v_adv    <- rbinom(n = n_ind, size = 1, prob = p_adv) # sample individuals who will experience adverse events
v_dead   <- as.numeric(m_M[,1] == "Dead")
# costs and effects
# m_c[,1]     <- Costs(v_M = m_M[,1], adverse = T, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1])
# m_c_trt[,1] <- Costs(v_M = m_M[,1], adverse = T, v_adverse = v_adv, trt = T, k = k, dc = v_dc[1])
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_c_trt[,1] <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = T, k = k, dc = v_dc[1]) # DELETE THIS AFTER
# m_c    [v_dead == 1, 1] <- m_c    [v_dead == 1, 1] + m_costs[k,"cost_D"] * v_dc[1] # UNCOMMENT
# m_c_trt[v_dead == 1, 1] <- m_c_trt[v_dead == 1, 1] + m_costs[k,"cost_D"] * v_dc[1]
m_u[, 1]     <- Utils(v_M = m_M[,1], trt = F, de = v_de[1])
m_u_trt[, 1] <- Utils(v_M = m_M[,1], trt = T, de = v_de[1])
p_HS <- model.dist.f(dist.v = dist_HS, d.data = m_coef_HS[k,], t = times, step = c_l)[-1]
p_HD <- model.dist.f(dist.v = dist_HD, d.data = m_coef_HD[k,], t = times, step = c_l)[-1]
p_SD <- model.dist.f(dist.v = dist_SD, d.data = m_coef_SD[k,], t = times, step = c_l)[-1]
# open a loop for time, running cycles 1 to n_t
for (t in 1:(n_cy - 1)) {
# calculate the transition probabilities for the cycle based on health state t
m_p        <- Probs(m_M[, t], v_Ts, t, p_HS, p_HD, p_SD)
# sample next state based on transition probabilities in m_p
m_M[,t+1]  <- samplev(m_p)
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c_trt[,t+1] <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = T, dc = v_dc[t+1])
# UNCOMMENT
# m_c    [(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] <- m_c    [(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] + m_costs[k,"cost_D"] * v_dc[t+1]
# m_c_trt[(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] <- m_c_trt[(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] + m_costs[k,"cost_D"] * v_dc[t+1]
v_dead <- as.numeric(m_M[, t+1] == "Dead")
m_u[,t+1]     <- Utils(v_M = m_M[,t+1], trt = F, de = v_de[t+1])
m_u_trt[,t+1] <- Utils(v_M = m_M[,t+1], trt = T, de = v_de[t+1])
# update time since illness onset for t + 1
v_Ts <- ifelse(m_M[, t + 1] == "Sick", v_Ts + 1, 0)
} # close the loop for the time points
m_M_Micro <- t(apply(m_M, 2, function(x) table(factor(x, levels = v_s, ordered = TRUE))))
m_M_Micro <- m_M_Micro / n_ind    # calculate the proportion of individuals
m_M_Micro <- cbind(times, m_M_Micro)
colnames(m_M_Micro) <- c("Cycle", v_s)
rownames(m_M_Micro) <- paste("Cycle", times, sep = " ")
le_Micro    <- sum(m_M_Micro[,2:3]) * c_l
c_Micro     <- sum(m_c)/n_ind
u_Micro     <- sum(m_u)/n_ind * c_l
c_trt_Micro <- sum(m_c_trt)/n_ind
u_trt_Micro <- sum(m_u_trt)/n_ind * c_l
# Outputs for trial period
le_trial    <- sum(m_M_Micro[1:(trial_t/c_l),][,2:3]) * c_l
c_trial     <- sum(m_c    [,1:(trial_t/c_l)])/n_ind
u_trial     <- sum(m_u    [,1:(trial_t/c_l)])/n_ind * c_l
c_trt_trial <- sum(m_c_trt[,1:(trial_t/c_l)])/n_ind
u_trt_trial <- sum(m_u_trt[,1:(trial_t/c_l)])/n_ind * c_l
outputs[nrow(outputs)+1,]   <- c(le_Micro, c_Micro, u_Micro,
c_trt_Micro, u_trt_Micro)
df_trial[nrow(df_trial)+1,] <- c(le_trial, c_trial, u_trial,
c_trt_trial, u_trt_trial)
# Survival for each cycle in this simulation run: Sum columns of states that aren't death.
# Assumes the last column is death state
m_surv[k,] <- rowSums(m_M_Micro[, 2:n_s])
# Display simulation progress
if(k %in% seq(0,n_sim,5)) { # display progress every 10%
cat('\r', paste(round(k/n_sim*100,0), "% done", sep = " "))
} else if (k == n_sim) {cat('\r', paste("100% done"))}
} # close loop for simulations
# Load functions
source("fun_3_state.R")
####################
# Input parameters
####################
n_sim  <- as.numeric(read.xlsx(wb, namedRegion = "n_sims",     colNames = F))    # Number of simulations
n_ind  <- as.numeric(read.xlsx(wb, namedRegion = "n_i",        colNames = F))    # Number of individuals
n_t    <- as.numeric(read.xlsx(wb, namedRegion = "n_years",    colNames = F))    # Number of time cycles (in years)
n_s    <- as.numeric(read.xlsx(wb, namedRegion = "n_s",        colNames = F))    # Number of states
init_s <- as.numeric(read.xlsx(wb, namedRegion = "state_init", colNames = F))    # Initial states
c_l    <- as.numeric(read.xlsx(wb, namedRegion = "cy_len",     colNames = F))    # Cycle length
times  <- seq(from = 0, to = n_t, by = c_l)                                      # Vector of time points
n_cy   <- length(times)                                                          # Number of time points
trial_t<- as.numeric(read.xlsx(wb, namedRegion = "n_yr_t",     colNames = F))    # Number of years of trial
surv_t <- as.numeric(read.xlsx(wb, namedRegion = "surv_t",     colNames = F))    # Present survival at time:
p_adv  <- as.numeric(read.xlsx(wb, namedRegion = "p_adverse",  colNames = F))    # Probability of AE
v_s    <- as.character(read.xlsx(wb, namedRegion = "name_states", colNames = F)) # Vector of states
v_grp  <- as.character(read.xlsx(wb, namedRegion = "name_groups", colNames = F)) # Vector of group names
psa    <- as.character(read.xlsx(wb, namedRegion = "psa", colNames = F))         # Probabilistic Analysis? (Y/N)
dwc    <- as.numeric(read.xlsx(wb, namedRegion = "dwc", colNames = F))           # Discounting rate for costs
dwe    <- as.numeric(read.xlsx(wb, namedRegion = "dwe", colNames = F))           # Discounting rate for effects
v_dc   <- 1 / ((1 + dwc) ^ (times))                                              # Vector of discount weights for costs
v_de   <- 1 / ((1 + dwe) ^ (times))                                              # Vector of discount weights for utilities
# Ceiling Ratio (willingness to pay)
ceiling_ratio <- read.xlsx(wb, namedRegion = "ceiling_ratio", colNames = F)
###########################################
# Input parameters: Surv
## psa params generated by psa_param_gen.R
###########################################
# Import sampled survival distribution coefficients from Excel
m_coef_HS <- as.matrix(   read.xlsx(wb, namedRegion = "psa_HS",  colNames = F)) # Healthy to Sick
m_coef_HD <- as.matrix(   read.xlsx(wb, namedRegion = "psa_HD",  colNames = F)) # Healthy to Dead
m_coef_SD <- as.matrix(   read.xlsx(wb, namedRegion = "psa_SD",  colNames = F)) # Sick to Dead
# Selected distribution from Excel
dist_HS   <- as.character(read.xlsx(wb, namedRegion = "dist_HS", colNames = F)) # Healthy to Sick
dist_HD   <- as.character(read.xlsx(wb, namedRegion = "dist_HD", colNames = F)) # Health to Dead
dist_SD   <- as.character(read.xlsx(wb, namedRegion = "dist_SD", colNames = F)) # Sick to Dead
#########################################
# Input parameters: Costs
#########################################
m_costs    <- read.xlsx(wb, namedRegion = "m_cost", colNames = F)
cost_names <- m_costs[1,]
m_costs    <- m_costs[-1,]
m_costs    <- matrix(as.numeric(as.matrix(m_costs)), nrow = n_sim)
colnames(m_costs) <- cost_names
#########################################
# Organize Costs in matrices for SoC and Trt
## Rows   : Simulation
## Columns: State
#########################################
m_costs_soc <- matrix(c(rowSums(m_costs[,c("cost_PF_acq_soc", "cost_PF_admin_soc", "cost_PF_soc")]), # Healthy
rowSums(m_costs[,c("cost_P_acq_soc", "cost_P_soc")]),                        # Sick
rep(0, n_sim)),                                                              # Dead
nrow = n_sim)
m_costs_trt <- matrix(c(rowSums(m_costs[,c("cost_PF_acq_trt", "cost_PF_admin_trt", "cost_PF_trt")]), # Healthy
rowSums(m_costs[,c("cost_P_acq_trt", "cost_P_trt")]),                        # Sick
rep(0, n_sim)),                                                              # Dead
nrow = n_sim)
# Costs for adverse events
costs_adv <- m_costs[,"cost_adv"]
#########################################
# Import Utilities
#########################################
u_H   <- as.numeric(read.xlsx(wb, namedRegion = "util_H", colNames = F))
u_S   <- as.numeric(read.xlsx(wb, namedRegion = "util_S", colNames = F))
u_D   <- as.numeric(read.xlsx(wb, namedRegion = "util_D", colNames = F))
u_trt <- as.numeric(read.xlsx(wb, namedRegion = "util_T", colNames = F))
v_utils     <- c(u_H, u_S, u_D)
v_utils_trt <- c(u_H, u_trt, u_D)
####################
# Initialize vectors
####################
v_M_init  <- rep(v_s[init_s], times = n_ind)    # Vector state individuals start in
v_Ts_init <- ifelse(v_M_init == v_s[2],c_l, 0)  # Vector with the time of being Sick at the start of the model
######################################
# Run microsim and write to txt files
######################################
outputs <- df_trial  <- data.frame(le = as.numeric(),
costs = as.numeric(),
effects = as.numeric(),
`trt costs` = as.numeric(),
`trt effects` = as.numeric())
m_surv <- matrix(NA,
nrow = n_sim,
ncol = n_cy)
k<-1
# m_M is used to store the health state information over time for every individual
# m_c, m_u, m_c_trt, m_u_trt are used to store cost, utilities, treatment costs and treatment utilities for every individual, respectively
m_M  <-  matrix(nrow = n_ind, ncol = n_cy ,
dimnames = list(paste("ind" , 1:n_ind, sep = " "),
paste("year", times, sep = " ")))
m_c <- m_u <- m_c_trt <- m_u_trt <- m_M
m_M[, 1] <- v_M_init                                  # initial health state for individual i
v_Ts     <- v_Ts_init                                 # initialize time since illness onset for individual i
v_adv    <- rbinom(n = n_ind, size = 1, prob = p_adv) # sample individuals who will experience adverse events
v_dead   <- as.numeric(m_M[,1] == "Dead")
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_c_trt[,1] <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = T, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_u[, 1]     <- Utils(v_M = m_M[,1], trt = F, de = v_de[1])
m_u_trt[, 1] <- Utils(v_M = m_M[,1], trt = T, de = v_de[1])
p_HS <- model.dist.f(dist.v = dist_HS, d.data = m_coef_HS[k,], t = times, step = c_l)[-1]
p_HD <- model.dist.f(dist.v = dist_HD, d.data = m_coef_HD[k,], t = times, step = c_l)[-1]
p_SD <- model.dist.f(dist.v = dist_SD, d.data = m_coef_SD[k,], t = times, step = c_l)[-1]
# open a loop for time, running cycles 1 to n_t
for (t in 1:(n_cy - 1)) {
# calculate the transition probabilities for the cycle based on health state t
m_p        <- Probs(m_M[, t], v_Ts, t, p_HS, p_HD, p_SD)
# sample next state based on transition probabilities in m_p
m_M[,t+1]  <- samplev(m_p)
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c_trt[,t+1] <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = T, dc = v_dc[t+1])
# UNCOMMENT
# m_c    [(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] <- m_c    [(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] + m_costs[k,"cost_D"] * v_dc[t+1]
# m_c_trt[(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] <- m_c_trt[(v_dead != 1 & m_M[,t+1] == "Dead"), t+1] + m_costs[k,"cost_D"] * v_dc[t+1]
v_dead <- as.numeric(m_M[, t+1] == "Dead")
m_u[,t+1]     <- Utils(v_M = m_M[,t+1], trt = F, de = v_de[t+1])
m_u_trt[,t+1] <- Utils(v_M = m_M[,t+1], trt = T, de = v_de[t+1])
# update time since illness onset for t + 1
v_Ts <- ifelse(m_M[, t + 1] == "Sick", v_Ts + 1, 0)
} # close the loop for the time points
m_c
colSums(m_c)
colSums(m_c)/n_ind
colSums(m_c)/n_ind
as.vector(colSums(m_c)/n_ind)
as.vector(colSums(m_c_trt)/n_ind)
14793 - 7426.483698
m_M
m_M[,2]
m_M[,2]=="Heahlthy"
Sum(m_M[,2]=="Healthy")
(m_M[,2]=="Healthy")
sum(m_M[,2]=="Healthy")
sum(m_M[,2]=="Healthy")/n_ind
which(m_M[,2] == "Healthy")
pos1 <- which(m_M[,2] == "Healthy")
m_M[pos1,2]
m_c[pos1,2]
m_M[pos1,2]
table(m_M[pos1,2])
m_c[,2]
m_c[pos1,2]
m_c[,2]
average(m_c[,2])
mean(m_c[,2])
0.994*m_costs_soc[1,1]
k<-1
outputs <- df_trial  <- data.frame(le = as.numeric(),
costs = as.numeric(),
effects = as.numeric(),
`trt costs` = as.numeric(),
`trt effects` = as.numeric())
m_surv <- matrix(NA,
nrow = n_sim,
ncol = n_cy)
k
# m_M is used to store the health state information over time for every individual
# m_c, m_u, m_c_trt, m_u_trt are used to store cost, utilities, treatment costs and treatment utilities for every individual, respectively
m_M  <-  matrix(nrow = n_ind, ncol = n_cy ,
dimnames = list(paste("ind" , 1:n_ind, sep = " "),
paste("year", times, sep = " ")))
m_c <- m_u <- m_c_trt <- m_u_trt <- m_M
m_M[, 1] <- v_M_init                                  # initial health state for individual i
v_Ts     <- v_Ts_init                                 # initialize time since illness onset for individual i
v_adv    <- rbinom(n = n_ind, size = 1, prob = p_adv) # sample individuals who will experience adverse events
v_dead   <- as.numeric(m_M[,1] == "Dead")
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_c_trt[,1] <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = T, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_u[, 1]     <- Utils(v_M = m_M[,1], trt = F, de = v_de[1])
m_u_trt[, 1] <- Utils(v_M = m_M[,1], trt = T, de = v_de[1])
p_HS <- model.dist.f(dist.v = dist_HS, d.data = m_coef_HS[k,], t = times, step = c_l)[-1]
p_HD <- model.dist.f(dist.v = dist_HD, d.data = m_coef_HD[k,], t = times, step = c_l)[-1]
p_SD <- model.dist.f(dist.v = dist_SD, d.data = m_coef_SD[k,], t = times, step = c_l)[-1]
t<-1
# calculate the transition probabilities for the cycle based on health state t
m_p        <- Probs(m_M[, t], v_Ts, t, p_HS, p_HD, p_SD)
# sample next state based on transition probabilities in m_p
m_M[,t+1]  <- samplev(m_p)
v_M = m_M[,t+1]
adverse = F
v_adverse = v_adv
trt = F
dc = v_dc[t+1]
k = k
pos.1 <- which(v_M == v_s[1])
pos.2 <- which(v_M == v_s[2])
pos.3 <- which(v_M == v_s[3])
pos.1
pos.2
pos.3
which(m_M[,2] == "Healthy")
which(m_M[,2] == "Sick")
which(m_M[,2] == "Dead")
v_c <- vector(mode = "numeric", length = length(v_M))
options(warn=-1)
v_c[pos.1] <- m_costs_soc[k,1]
# v_c[pos.2] <- m_costs_soc[k,2]
v_c[pos.2] <- 0
v_c[pos.3] <- m_costs_soc[k,3]
v_c[pos.1]
m_costs_soc[k,1]
v_c[pos.2]
v_c[pos.3]
v_c
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_c[,1]
m_c[,1] == v_c
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c[,t+1]
m_c[,t+1]  == v_c
return(v_c)
#'
#' @param v_M       vector of individuals states for cycle
#' @param adverse   add adverse event costs? (T/F)
#' @param v_adverse vector of individuals adverse event status
#' @param trt       treatment group? (T/F)
#' @param k         simulation number
#' @param dc        discounting factor this cycle
#'
#' @return          vector of discounted costs
#'
Costs <- function(v_M, adverse, v_adverse = v_adv, trt, k = k, dc = 1){
pos.1 <- which(v_M == v_s[1])
pos.2 <- which(v_M == v_s[2])
pos.3 <- which(v_M == v_s[3])
v_c <- vector(mode = "numeric", length = length(v_M))
options(warn=-1)
if (trt == F){
v_c[pos.1] <- m_costs_soc[k,1]
# v_c[pos.2] <- m_costs_soc[k,2]
v_c[pos.2] <- 0
v_c[pos.3] <- m_costs_soc[k,3]
}else if(trt == T){
v_c[pos.1] <- m_costs_trt[k,1]
# v_c[pos.2] <- m_costs_trt[k,2]
v_c[pos.2] <- 0
v_c[pos.3] <- m_costs_trt[k,3]
}
if(adverse == T){
v_c[v_adverse == 1] = v_c[v_adverse == 1] + costs_adv[k]
}
options(warn = 0)
return(v_c)
#* dc
}
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c[,t+1]
Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
v_c
m_M[,t+1]
trt
trt
trt
trt
adverse
v_c
pos.1 <- which(v_M == v_s[1])
pos.2 <- which(v_M == v_s[2])
pos.3 <- which(v_M == v_s[3])
v_c <- vector(mode = "numeric", length = length(v_M))
options(warn=-1)
if (trt == F){
v_c[pos.1] <- m_costs_soc[k,1]
# v_c[pos.2] <- m_costs_soc[k,2]
v_c[pos.2] <- 0
v_c[pos.3] <- m_costs_soc[k,3]
}else if(trt == T){
v_c[pos.1] <- m_costs_trt[k,1]
# v_c[pos.2] <- m_costs_trt[k,2]
v_c[pos.2] <- 0
v_c[pos.3] <- m_costs_trt[k,3]
}
if(adverse == T){
v_c[v_adverse == 1] = v_c[v_adverse == 1] + costs_adv[k]
}
options(warn = 0)
v_c
m_c[,1]     <- Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = k, dc = v_dc[1]) # DELETE THIS AFTER
m_c[,1]
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
m_c[,t+1]
Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = v_dc[t+1])
Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, dc = 1)
v_adv
t+1
Costs(v_M = m_M[,1], adverse = F, v_adverse = v_adv, trt = F, k = 1, dc = v_dc[1])
v_M = m_M[,t+1]
# costs and effects
m_c[,t+1]     <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = F, k=k, dc = v_dc[t+1])
m_c[,t+1]
m_c_trt[,t+1] <- Costs(v_M = m_M[,t+1], adverse = F, v_adverse = v_adv, trt = T, k=k, dc = v_dc[t+1])
m_M_Micro
n_s
